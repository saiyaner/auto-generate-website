const fs = require('fs');
const path = require('path');
const { Client } = require('pg');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const { updateProxyMap, getNginxReloadCommand } = require('./nginx-updater');

// Database Config
const client = new Client({
    connectionString: process.env.DATABASE_URL || 'postgres://postgres:password123@localhost:5432/homelab_auto_gen'
});

// Configuration
const IS_DRY_RUN = process.env.DRY_RUN === 'true' || process.platform === 'win32'; // Default to dry-run on Windows
const BASE_CONTAINER_DIR = process.env.CONTAINER_DIR || path.join(__dirname, '..', 'containers');

// Usage: node scripts/generator.js <action> <payload>
const action = process.argv[2];
const payloadStr = process.argv[3];
const payload = payloadStr ? JSON.parse(payloadStr) : {};

console.log(`[RealGenerator] Starting action: ${action}`);
if (IS_DRY_RUN) console.log('[RealGenerator] Mode: DRY RUN (No commands will be executed)');

async function runCommand(command, cwd = process.cwd()) {
    console.log(`[CMD] ${command}`);
    if (IS_DRY_RUN) return { stdout: 'Mock Success', stderr: '' };

    try {
        const { stdout, stderr } = await execPromise(command, { cwd });
        return { stdout, stderr };
    } catch (error) {
        console.error(`[CMD Failed] ${command}`, error.message);
        throw error;
    }
}

async function main() {
    try {
        await client.connect();
    } catch (err) {
        console.log('[RealGenerator] Warning: Database disconnected (Running in offline mode if acceptable).');
    }

    try {
        switch (action) {
            case 'create':
                await createWebsite(payload);
                break;
            case 'start':
                await startWebsite(payload);
                break;
            case 'stop':
                await stopWebsite(payload);
                break;
            case 'delete':
                await deleteWebsite(payload);
                break;
            default:
                console.log('Unknown action');
        }
    } catch (err) {
        console.error('[RealGenerator] Critical Error:', err);
    } finally {
        await client.end();
    }
}

async function createWebsite(data) {
    console.log(`[RealGenerator] Creating website: ${data.name} (${data.template})`);

    // 1. Validate inputs
    if (!data.name || !data.template) {
        console.error('[RealGenerator] Error: Missing name or template');
        throw new Error('Missing inputs');
    }

    const workspaceDir = path.join(BASE_CONTAINER_DIR, data.name);
    const imageName = `website-${data.name.toLowerCase()}`;
    const containerName = `website-${data.name.toLowerCase()}`;

    // 2. Prepare Workspace (Folders & Dockerfile)
    if (!fs.existsSync(workspaceDir)) {
        console.log(`[RealGenerator] Creating directory: ${workspaceDir}`);
        if (!IS_DRY_RUN) fs.mkdirSync(workspaceDir, { recursive: true });
    }

    // Generate Dockerfile content based on template
    let dockerfileContent = '';
    if (data.template.toLowerCase() === 'html') {
        dockerfileContent = `FROM nginx:alpine
COPY . /usr/share/nginx/html
EXPOSE 80`;
    } else if (data.template.toLowerCase() === 'node') {
        dockerfileContent = `FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["npm", "start"]
EXPOSE ${data.port}`;
    } else if (data.template.toLowerCase() === 'php') {
        dockerfileContent = `FROM php:8.2-apache
COPY . /var/www/html/
EXPOSE 80`;
    } else if (data.template.toLowerCase() === 'python') {
        dockerfileContent = `FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]
EXPOSE ${data.port}`;
    }

    // Write Dockerfile
    if (!IS_DRY_RUN) {
        fs.writeFileSync(path.join(workspaceDir, 'Dockerfile'), dockerfileContent);
        // Create a dummy index.html if needed for testing HTML template
        if (data.template.toLowerCase() === 'html' && !fs.existsSync(path.join(workspaceDir, 'index.html'))) {
            fs.writeFileSync(path.join(workspaceDir, 'index.html'), `<h1>Hello from ${data.name}</h1><p>Generated by AutoWeb</p>`);
        }
    }
    console.log(`[RealGenerator] Dockerfile and assets prepared.`);

    // 3. Podman Build
    // Note: In production, we might need --network host or other flags
    await runCommand(`podman build -t ${imageName} .`, workspaceDir);

    // 4. Podman Run
    // Map hostPort:containerPort. 
    // HTML/PHP usually expose 80 inside. Node/Python expose specific ports, need to match.
    let containerPort = 80;
    if (['node', 'python'].includes(data.template.toLowerCase())) {
        // For node/python, we usually expect them to run on the PORT env var or fixed port
        // Simplification: Assume they listen on the passed data.port inside too, OR we pass -e PORT
        containerPort = data.port;
    }

    // Stop existing if any
    await runCommand(`podman rm -f ${containerName} || true`);

    const runCmd = `podman run -d -p ${data.port}:${containerPort} --name ${containerName} --restart always ${imageName}`;
    await runCommand(runCmd);


    console.log(`[RealGenerator] SUCCESS: Container running on port ${data.port}`);

    // 5. DB Update / Fallback to JSON
    try {
        if (!IS_DRY_RUN && client) {
            console.log('[RealGenerator] Updating database...');
            const queryText = `
                INSERT INTO websites (user_id, name, subdomain, template_id, status, port) 
                VALUES (1, $1, $2, 1, 'running', $3)
                ON CONFLICT (subdomain) DO UPDATE SET status = 'running', port = $3;
            `;
            await client.query(queryText, [data.name, data.name, data.port]);
            console.log('[RealGenerator] Database updated successfully.');
        } else {
            throw new Error('Dry run mode - using JSON fallback');
        }
    } catch (e) {
        console.log('[RealGenerator] Using JSON fallback for persistence...');

        // Fallback: Write to JSON file
        try {
            const mockFilePath = path.join(__dirname, '../data/mock_db.json');
            let mockData = [];
            if (fs.existsSync(mockFilePath)) {
                mockData = JSON.parse(fs.readFileSync(mockFilePath, 'utf-8'));
            }

            // Check for duplicates
            const exists = mockData.some(site => site.name.toLowerCase() === data.name.toLowerCase());
            if (exists) {
                console.log(`[RealGenerator] Error: Website "${data.name}" already exists!`);
                return;
            }

            const newSite = {
                id: Math.floor(Math.random() * 10000),
                name: data.name,
                subdomain: data.name,
                status: 'running',
                port: data.port,
                type: data.template.toUpperCase()
            };

            mockData.push(newSite);
            fs.writeFileSync(mockFilePath, JSON.stringify(mockData, null, 2));
            console.log('[RealGenerator] Fallback: Wrote to mock_db.json');

            // Update Nginx proxy mapping
            try {
                updateProxyMap(mockData.map(site => ({
                    subdomain: site.subdomain.toLowerCase(),
                    port: site.port
                })));

                // Reload Nginx (only on Linux)
                if (process.platform !== 'win32') {
                    const reloadCmd = getNginxReloadCommand();
                    await runCommand(reloadCmd);
                    console.log('[RealGenerator] Nginx configuration reloaded');
                } else {
                    console.log(`[RealGenerator] Skipping Nginx reload on Windows. Run on server: ${getNginxReloadCommand()}`);
                }
            } catch (nginxErr) {
                console.warn('[RealGenerator] Nginx update failed (non-critical):', nginxErr.message);
            }
        } catch (fileErr) {
            console.error('[RealGenerator] Fallback Failed:', fileErr.message);
        }
    }
}

async function startWebsite(data) {
    const containerName = `website-${data.name.toLowerCase()}`;
    await runCommand(`podman start ${containerName}`);
}

async function stopWebsite(data) {
    const containerName = `website-${data.name.toLowerCase()}`;
    await runCommand(`podman stop ${containerName}`);
}

async function deleteWebsite(data) {
    const containerName = `website-${data.name.toLowerCase()}`;
    await runCommand(`podman rm -f ${containerName}`);
    // Optional: podman rmi ...
}

main().catch(console.error);
